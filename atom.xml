<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cheer</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-05T03:59:37.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>马权讷讷</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS10 User Notifications 学习笔记</title>
    <link href="http://yoursite.com/2016/06/27/iOS10%20UserNotifications%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/06/27/iOS10 UserNotifications 学习笔记/</id>
    <published>2016-06-27T15:17:41.000Z</published>
    <updated>2016-08-05T03:59:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/65312d9agw1f5a8zns61uj215y0esdgp.jpg" alt="Advanced Notifications"></p>
<p><strong>注意：此文章涉及代码内容运行环境为 iOS10 Beta1</strong></p>
<p>这几天研究了一下 iOS10 的 User Notifications，相比于老的，新的通知中心增加了一些功能，比如以 Extension 形式提供给用户使用的 <code>UNNotificationContentExtension（通知内容扩展）</code> ；供开发者自定义通知触发条件的 <code>UNNotificationTrigger（触发条件设定）</code>；以及提供用户可加入 <code>UNNotificationAttachment（通知附件）</code> 用来预览。除此之外苹果的 PDF 上还写其它几项优势：</p>
<ul>
<li>和功能更加相似的 API 设计</li>
<li>处理远程推送和本地推送处的代码位置相同</li>
<li>简单的代理使用模式以及更好的通知管理</li>
<li>当然最重要一点：通知扩展 Notification Extension</li>
</ul>
<a id="more"></a>
<p>具体我会从下面几个方面介绍新通知中心的功能：</p>
<ul>
<li>1 . UNNotificationTrigger（通知触发条件设定）</li>
<li>2 . UNNotificationAttachment （通知附件）</li>
<li>3 . UNNotificationContentExtension （通知内容扩展）</li>
<li>4 . UNNotificationServiceExtension （通知服务扩展）</li>
<li>5 . UNNotificationAction （通知响应事件）</li>
</ul>
<p>并且在文章最后给出具体的的 Demo 供大家参考。</p>
<h2 id="1-UNNotificationTrigger-通知触发条件设定"><a href="#1-UNNotificationTrigger-通知触发条件设定" class="headerlink" title="1. UNNotificationTrigger - 通知触发条件设定"></a>1. UNNotificationTrigger - 通知触发条件设定</h2><p><img src="http://ww3.sinaimg.cn/large/65312d9agw1f59uzqam85j21kw0iaq55.jpg" alt="Trigger"></p>
<p>A UNNotificationTrigger object represents an event that triggers the delivery of a notification. This class is abstract, so you do not create instances of it directly. Instead, you create instances of a concrete subclass that define the trigger conditions you want. You then use the trigger object to create the UNNotificationRequest object needed to schedule the delivery of the notification.</p>
<p>Trigger 是新加入的一个功能，通过此类可设置本地通知的触发条件。UNNotificationTrigger 是通知触发条件类的基类，不应该直接使用它，而是使用下面这些子类：</p>
<ul>
<li>UNPushNotificationTrigger</li>
</ul>
<p>这个是苹果通知服务的 Trigger，对外没有暴露任何接口属性，不需要开发者创建，由系统创建。</p>
<ul>
<li>UNTimeIntervalNotificationTrigger 时间触发器</li>
</ul>
<p>通过初始化方法设置通知的<code>timeInterval（触发间隔）</code>和<code>repeats（是否重复触发）</code>，若 repeats 设置为 false，通知将在 timeInterval 之后被推送。</p>
<ul>
<li>UNCalendarNotificationTrigger 日期触发器</li>
</ul>
<p>类似 UNTimeIntervalNotificationTrigger，也是时间触发器，只不过初始化时第一个参数为 <code>DateComponents</code> 类型，可设置具体的触发时间比如<code>8:00 AM</code>等，也可设置是否重复触发。</p>
<ul>
<li>UNLocationNotificationTrigger 位置触发器</li>
</ul>
<p>通过设置 <code>CLRegion</code> 类型参数设置位置信息，当用户处于某一区域时，自动推送通知。</p>
<p><strong>使用：</strong></p>
<p>初始化 UNNotificationRequest（通知请求）时传入 UNNotificationTrigger 实例，来设置推送通知触发条件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  通知触发条件设定为2秒触发一次</span></div><div class="line"><span class="keyword">let</span> trigger = <span class="type">UNTimeIntervalNotificationTrigger</span>.<span class="keyword">init</span>(timeInterval: <span class="number">2</span>,</div><div class="line">                                                     repeats: <span class="literal">true</span>)</div><div class="line">                                                     </div><div class="line"><span class="comment">//  创建通知请求，设置触发器</span></div><div class="line"><span class="keyword">let</span> request = <span class="type">UNNotificationRequest</span>.<span class="keyword">init</span>(identifier: identifier,</div><div class="line">                                         content: content,</div><div class="line">                                         trigger: trigger)</div></pre></td></tr></table></figure>
<h2 id="2-UNNotificationAttachment-通知附件"><a href="#2-UNNotificationAttachment-通知附件" class="headerlink" title="2. UNNotificationAttachment - 通知附件"></a>2. UNNotificationAttachment - 通知附件</h2><p><img src="http://ww2.sinaimg.cn/large/65312d9agw1f59vm2s2uwj21gc0g2acx.jpg" alt="Attachment"></p>
<p>A UNNotificationAttachment object contains audio, image, or video content to display alongside the notification content. Your app always supplies attachments. For local notifications, the app adds attachments when creating the rest of the notification’s content. You can add attachments to a remote notification by implementing a notification service extension, as represented by the UNNotificationServiceExtension class.</p>
<p>推送的通知允许夹带一个附件，格式支持视频，音频，图片。</p>
<p>苹果的文档中对文件的类型和大小做了如下限制：</p>
<p style="text-align: center"><img src="http://ww1.sinaimg.cn/large/65312d9agw1f5a6clk2uij20lq0ki0u7.jpg" width="350"><br></p>

<p><strong>使用：</strong></p>
<ul>
<li>对于本地通知，创建 UNMutableNotificationContent（通知内容）时设置 attachments （附件）属性即可加入附件。</li>
<li>对于远程推送通知服务，需要实现 UNNotificationServiceExtension（通知服务扩展），在回调方法中处理 推送内容时设置 request.content.attachments（请求内容的附件） 属性，之后调用 contentHandler 方法即可。</li>
<li>无论是本地或者远程推送，如果没有设置 UNNotificationContentExtension （通知内容扩展），设备下拉或重压后，附件会直接出现在 Content 中。如下图：</li>
</ul>
<p style="text-align: center"><img src="http://ww2.sinaimg.cn/large/65312d9agw1f5a7x2lu34j20a80dw0tl.jpg" width="250"><br></p>

<p>这里需要说明的是 UNNotificationAttachment 的初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">(identifier: String, url URL: URL, options: [NSObject : AnyObject]? = [:])</span></span> <span class="keyword">throws</span></div></pre></td></tr></table></figure>
<p>的第二个参数 <code>url</code> 指的是附件的 url，此附件必须在本地硬盘上，否则创建时可能出现异常抛出。</p>
<p>如果采取的是本地推送，直接读取文件的所在的位置的 URL 即可；如果是远程推送，由于 attachments 的设置是在 NotificationServiceExtension 的 Target 中，若需读取 Bundle 中的文件，记得将资源加入 NotificationServiceExtension Target 的 Copy Bundle Resource，不能直接读取 Containing App Target 中的 Bundle Resource。</p>
<h2 id="3-UNNotificationContentExtension-通知内容扩展"><a href="#3-UNNotificationContentExtension-通知内容扩展" class="headerlink" title="3. UNNotificationContentExtension - 通知内容扩展"></a>3. UNNotificationContentExtension - 通知内容扩展</h2><p><img src="http://ww4.sinaimg.cn/large/65312d9agw1f59y734woxj20py068mxu.jpg" alt="ContentExtension"></p>
<p>The UNNotificationContentExtension protocol lets you present a custom interface for your app’s notifications. You adopt this protocol in custom UIViewController subclasses, using the view controller’s view to display the notification contents. You deliver your view controller class inside a Notification Content extension.</p>
<p>iOS User Notifications 最大的革新在于加入了以 Extension 形式提供给开发者和用户使用的 UNNotificationContentExtension，但是只有支持 3DTouch 的设备下拉或重压才能呼出…，但是明明下拉也可以呼出的控件为什么不支持无 3DTouch 的设备，苹果这盘棋下的好啊。(注：以上均为 iOS10 beta1 下的表现；据说 beta2 下不支持 3DTouch 的的设备下拉也可以使用 UNNotificationContentExtension，后续等正式版在测试吧)</p>
<p>通知内容扩展需要新建一个 UNNotificationContentExtension Target，之后只需在 viewcontroller 的中实现相应的接口，即可以对 app 的通知页面进行自定义扩展，扩展主要用于自定义 UI。</p>
<p style="text-align: center"><img src="http://ww2.sinaimg.cn/large/65312d9agw1f5a0bmg3ngj207g08umxf.jpg" width="250"><br></p>

<p>创建好的 Extension Target 自带一个 ViewController，支持 stroyBoard 使用 autoLayout 布局，但是此 ViewController 不支持交互，加载上面的手势、button 等交互控件都将无效。若需交互，使用 UNNotificationAction （通知响应事件）提供按键或输入源，关于 UNNotificationAction 的用法之后 UNNotificationAction 小节会具体讲解。</p>
<p>扩展页面样式可以在 plist 中配置，提供三个 key 进行设置:</p>
<p><img src="http://ww4.sinaimg.cn/large/65312d9agw1f59zqq40ouj20ss07275w.jpg" alt="扩展配置"></p>
<ul>
<li>UNNotificationExtensionCategory: 要让通知支持内容扩展，需要将通知的 categoryIdentifier（类型标示） 加入此处。</li>
<li>UNNotificationExtensionDefaultContentHidden: 默认内容隐藏，如果设为 YES，则最下面通知 content 部分会隐藏。</li>
</ul>
<p style="text-align: center"><img src="http://ww4.sinaimg.cn/large/65312d9agw1f5a0cqbl7aj207e08maaa.jpg" width="250"><br></p>

<ul>
<li>UNNotificationExtensionIntialContentSizeRation: 初始内容 Size 的比例。也可以在 viewDidLoad 中使用 self.preferredContentSize 直接设置 Size。</li>
</ul>
<p style="text-align: center"><img src="http://ww2.sinaimg.cn/large/65312d9agw1f5a0b1ufmyj207c08yaae.jpg" width="250"><br></p>

<p><strong>使用：</strong></p>
<p>远程和本地通知最终都可以使用此扩展自定义 UI，只需将通知的 categoryIdentifier（类型标示） 加入到 plist 中即可。</p>
<ul>
<li>本地推送时，确保设置的 content.categoryIdentifier（通知内容类型标示） 已加入 plist 中。</li>
<li>远程推送，需要设置 category 字段，且确保值也已加入 plist 中。</li>
</ul>
<h2 id="4-UNNotificationServiceExtension-通知服务扩展"><a href="#4-UNNotificationServiceExtension-通知服务扩展" class="headerlink" title="4. UNNotificationServiceExtension - 通知服务扩展"></a>4. UNNotificationServiceExtension - 通知服务扩展</h2><p><img src="http://ww1.sinaimg.cn/large/65312d9agw1f5a7mmfbf7j21e60eqmzi.jpg" alt="ServiceExtension"></p>
<p>A UNNotificationServiceExtension object, the principle class for a Notification Service app extension, lets you process the payload of a remote (sometimes called push) notification before it is delivered to the user.</p>
<p>UNNotificationServiceExtension 提供在远程推送将要被 push 出来前，处理推送显示内容的机会。此时可以对通知的 request.content 进行内容添加，如添加附件，userInfo 等。</p>
<p>通过远程推送的通知也支持 UNNotificationContentExtension，只需将 content.categoryIdentifier （通知内容类型标示） 的值设置为已经添加到 UNNotificationContentExtension plist 中的值即可。</p>
<p>服务器推送信息示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;aps&quot; : &#123;</div><div class="line">    &quot;alert&quot; : &#123;</div><div class="line">      &quot;title&quot; : &quot;title&quot;,</div><div class="line">      &quot;body&quot; : &quot;Your message Here&quot;		</div><div class="line">    &#125;,</div><div class="line">    // 开启可变内容</div><div class="line">    &quot;mutable-content&quot; : &quot;1&quot;,			</div><div class="line">    // category 为已添加入 UNNotificationContentExtension plist 的值时，即可支持 UNNotificationContentExtension</div><div class="line">    &quot;category&quot; : &quot;Cheer&quot;				</div><div class="line">  &#125;,</div><div class="line">  // 加入自定义数据，图片 url 路径</div><div class="line">  &quot;imageAbsoluteString&quot; : &quot;http://....jpg&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-UNNotificationAction-通知响应事件"><a href="#5-UNNotificationAction-通知响应事件" class="headerlink" title="5. UNNotificationAction 通知响应事件"></a>5. UNNotificationAction 通知响应事件</h2><p>A UNNotificationAction object represents a task that your app can perform in response to a notification. You can define custom different actions for each type of notification that your app supports. The action object itself contains information about how to display that action onscreen. When the user selects that action, the system forwards the action’s identifier string to your app so that you can perform the corresponding task.</p>
<p>UNNotificationAction 代表一个响应通知的事件。可以为每个通知设置不同的交互事件。下拉推送通知或处在锁屏界面侧滑通知时，会出现交互按键。</p>
<p>交互事件主要分为以下两类：</p>
<p><strong>UNNotificationAction：</strong></p>
<p>普通点击按键，可设置 identifier、 title 及 点击后的响应，例如：foreground 前台响应，destructive 点击后销毁通知，authenticationRequired 响应前是否需要解锁。</p>
<p style="text-align: center"><img src="http://ww4.sinaimg.cn/large/65312d9agw1f5a8uirxk9j20aa0hqwfh.jpg" width="250"><br></p>

<p>甚至可以使用 UNNotificationAction + accessoryInputView 结合，达到加入自定义辅助输入控件的效果：</p>
<p style="text-align: center"><img src="http://ww3.sinaimg.cn/large/65312d9agw1f5ei1fmukoj21ge0w6wig.jpg" width="600/"><br></p>

<p><strong>UNTextInputNotificationAction：</strong></p>
<p>当然也可以直接使用系统类 UNTextInputNotificationAction 创建输入框，但是风格比较固定，比如下面这种：</p>
<p style="text-align: center"><img src="http://ww4.sinaimg.cn/large/65312d9agw1f5a92073g9j20ac0e0mxx.jpg" width="250"><br></p>

<p>所以如果想自定义风格多样化的输入框，还是需要使用 UNNotificationAction + accessoryInputView。需要说的是，如果不支持 UNNotificationServiceExtension ，则不支持自定义 accessoryInputView。大概是因为如果不支持 UNNotificationContentExtension 扩展，那么就没有可自定义 UIViewController，自然就不能加 accessoryInputView 了。</p>
<p><strong>响应处理：</strong></p>
<p>若处于 UNNotificationContentExtension 通知扩展界面时，点击 <code>Comment</code> 按键会回调 UNNotificationContentExtension 扩展接口的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> response: UNNotificationResponse,</span></span></div><div class="line">                completionHandler completion: <span class="params">(UNNotificationContentExtensionResponseOption)</span> -&gt; <span class="type">Void</span>)</div></pre></td></tr></table></figure>
<p>如果不支持 UNNotificationContentExtension，就会是下面这种样式：</p>
<p style="text-align: center"><img src="http://ww3.sinaimg.cn/large/65312d9agw1f5hxw6fu78j20cy06y0ta.jpg" width="250"><br></p>

<p>则点击 <code>Comment</code> 回调 UNUserNotificationCenterDelegate 中的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">userNotificationCenter</span><span class="params">(<span class="number">_</span> center: UNUserNotificationCenter,</span></span></div><div class="line">                            didReceive response: UNNotificationResponse,</div><div class="line">                            withCompletionHandler completionHandler: <span class="params">()</span> -&gt; <span class="type">Void</span>) &#123;</div></pre></td></tr></table></figure>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>到这里 User Notifications 的功能就介绍的差不多了，可以看出几个核心的功能都需要 3DTouch (iOS10 Beta1 下)的支持，所以暂时在实用性方面还是比较受限制。</p>
<p>UNNotificationAttachment（附件） 的加入给产品的带来了更多的思路，这个方向还是很值得去探索的。</p>
<p>如果支持 3DTouch，UNTextInputNotificationAction 对于消息评论的回复或者微博的转发都是很方便的，这些不用处在 APP 前台就能完成。</p>
<p>更多代码实现请查看 <a href="https://github.com/maquannene/UserNotifications" target="_blank" rel="external">Demo</a>，如发现问题，请帮忙指正，感谢阅读。（Demo运行时，请重新设置证书配置文件方可运行）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/65312d9agw1f5a8zns61uj215y0esdgp.jpg&quot; alt=&quot;Advanced Notifications&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：此文章涉及代码内容运行环境为 iOS10 Beta1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这几天研究了一下 iOS10 的 User Notifications，相比于老的，新的通知中心增加了一些功能，比如以 Extension 形式提供给用户使用的 &lt;code&gt;UNNotificationContentExtension（通知内容扩展）&lt;/code&gt; ；供开发者自定义通知触发条件的 &lt;code&gt;UNNotificationTrigger（触发条件设定）&lt;/code&gt;；以及提供用户可加入 &lt;code&gt;UNNotificationAttachment（通知附件）&lt;/code&gt; 用来预览。除此之外苹果的 PDF 上还写其它几项优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和功能更加相似的 API 设计&lt;/li&gt;
&lt;li&gt;处理远程推送和本地推送处的代码位置相同&lt;/li&gt;
&lt;li&gt;简单的代理使用模式以及更好的通知管理&lt;/li&gt;
&lt;li&gt;当然最重要一点：通知扩展 Notification Extension&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="装逼指南" scheme="http://yoursite.com/categories/%E8%A3%85%E9%80%BC%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift Cache - Track 实现笔记</title>
    <link href="http://yoursite.com/2016/06/17/Swift%20Cache%20-%20Track/"/>
    <id>http://yoursite.com/2016/06/17/Swift Cache - Track/</id>
    <published>2016-06-17T04:47:53.000Z</published>
    <updated>2016-07-03T04:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>开始萌生出要写这个 <a href="https://github.com/maquannene/Track" target="_blank" rel="external"><strong>Cache</strong></a> 念头，是想要练习一下 <code>Swift</code> 这门语言，顺便实战 <code>GCD 达到多线程安全</code> 和思考 <code>如何写一个易用的库</code>。所以大概花了一个礼拜的时间完成了初级版，后续断断续续修补功能又花了两个礼拜，最终在 v1.2.0 的时候，达到了一个让我比较满意的程度。</p>
<p>这个库没有用到特别高深的技巧，也没有特别复杂的算法，但是完成的过程让我学习到了很多东西，如果你想要实战 GCD 的基本用法、又或者是想要学习库基本的设计等等，建议读下去。</p>
<a id="more"></a>
<h2 id="动手写之前"><a href="#动手写之前" class="headerlink" title="动手写之前"></a>动手写之前</h2><p>在开始写这个库之前，我已经拜读过 Objective-C 的一些 Cache 的源码，例如 Star 比较多的 <a href="https://github.com/tumblr/TMCache" target="_blank" rel="external">TMCache</a> 以及它的改良版 <a href="https://github.com/pinterest/PINCache" target="_blank" rel="external">PINCache</a>，以及功能不是那么强大的 EGOCache 和 SDImageCache，当然还有大名鼎鼎的 <a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a>。相比之下 Swift 的此类库就相对少一些，<a href="https://github.com/aschuch/AwesomeCache" target="_blank" rel="external">AwesomeCache</a> 算是 Star 相对多一些的库了，其他类似 Haneke 功能不在对比的范围内。</p>
<p>我对几个功能齐全的库的同步读写做了一个大概的测试（这里没有将任何一个 Swift 库加入对比中，因为确实没有找到功能比较齐全的库，比如 AwesomeCache 是没有区分 Memory 和 Disk 的，并且功能比较少。AwesomeCache 的 Memory 直接用的是 NSCache，所以我将 NSCache 加入了测试中）结果如下图：</p>
<p>下图为 <code>MemoryCache</code> 对随机产生的不重复 key value 数组进行读写测试：</p>
<p style="overflow: hidden;"><br><img src="http://ww3.sinaimg.cn/large/65312d9agw1f4ykk6mghoj20py0ig75w.jpg" width="350" style="float: left;"><img src="http://ww4.sinaimg.cn/large/65312d9agw1f4ykk81bclj20pq0iidhg.jpg" width="350" style="float: left;"><br></p>

<p>YY 和 Track 内部都采用了 LRU 淘汰算法，PIN 和 TM 有简单的淘汰功能，但并没有引入 LRU 算法，所以在写入后的淘汰数据阶段 YY 和 Track 要快于其他 Cache 的重排序淘汰。其中 TM 速度非常慢，原因在于 TM 的 GCD 调度策略存在很大的问题，会导致同步小数据读写性能都损耗在 GCD 的调度上。这里值得一说的是 NSCache 对随机 key value 的读写性能不错，尤其是读，但是一旦出现相似形数据，性能就会变得非常低。</p>
<p>下图为 <code>DiskCache</code> 对随机产生的不重复 key value 数组进行读写测试：</p>
<p style="overflow: hidden;"><br><img src="http://ww2.sinaimg.cn/large/65312d9agw1f4yk70sq6sj20p60iawfn.jpg" width="350" style="float: left;"><img src="http://ww2.sinaimg.cn/large/65312d9agw1f4yk724h6tj20ou0iegmt.jpg" width="350" style="float: left;"><br></p>

<p>很明显，底层采用 sqlite 的 YY 性能要高于其他所有基于文件系统的库，所以这里基本可以分为 YYDiskCache 和 其他DiskCache。</p>
<h2 id="开始动手写"><a href="#开始动手写" class="headerlink" title="开始动手写"></a>开始动手写</h2><p>在动手之前，已经了解到了各个库的优劣，所以在写的时候，我尽量提取了一些优点融入了 Track 中，接下来会主要针对以下几点进行说明，某些点对缓存的性能起到了决定性的作用：</p>
<h4 id="1-线程调度"><a href="#1-线程调度" class="headerlink" title="1.线程调度"></a>1.线程调度</h4><p>良好的线程调度，是高性能的一个重要保证，如果没有使用良好的线程调度，就会造成上图中 TMMemoryCache 那种结果。（下面都是针对同步操作的效率的讨论，异步操作讨论意义不大）</p>
<p>因为 Cache 要保证多线程安全，那么就必须有一套好的线程调度，经过一些源码的研究，我发现大部分缓存采取的线程调度策略分为下面两种：</p>
<p><strong>方式一：</strong> <code>并发队列 + barrier</code> + <code>信号量等待</code> 或 <code>串行队列</code> + <code>信号量等待</code></p>
<ul>
<li><p>异步操作方式：</p>
<ul>
<li>读：异步到操作队列调用非线程安全读操作（例 TMMemoryCache 或 TMDiskCache）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_async(_queue, ^&#123;</div><div class="line">//  非线程安全读操作</div><div class="line">//  objectForKey...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>写：</li>
</ul>
<p>如果操作队列为并发队列，使用 barrier_async 调用非线程安全写（例  TMMemoryCache）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_barrier_async(_currentQueue, ^&#123;</div><div class="line">//  非线程安全写操作</div><div class="line">//  setObjectForKey</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果操作队列为串行队列，那么只需 async 调用非线程安全写，不需要加 barrier</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_async(_serialQueue, ^&#123;</div><div class="line">//  非线程安全写操作</div><div class="line">//  setObjectForKey </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>同步操作方式：调用上述异步操作方式，外部加信号量锁，变同步（例：TMMemoryCache 或 TMDiskCache）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</div><div class="line">// 线程安全异步读写</div><div class="line">async_thread_safe_write_or_read(^&#123;</div><div class="line">    dispatch_semaphore_signal(semaphore);</div><div class="line">&#125;);</div><div class="line">// 等待信号变同步</div><div class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>总结：</strong>上述这种模型，如果使用的是<code>并发队列</code>，即 TMMemoryCache，最终能达到读取时支持大并发同步读，写入时用 barrier 保证了写入的原子性、并且和读操作之间的互斥性。</p>
<p><code>并发队列</code> + <code>barrier</code> 亦或者直接使用 <code>串行队列</code> 看似是一个十分完美的解决方案，但是实际上隐藏着很大的弊端，因为往往使用者会忽略掉线程切换造成的性能损耗。千万不要小看这一点损耗，试着想一下，如果我们写入或者读取的数据非常小，那么就会造成实际写入或者读取的时间远小于线程切换的时间，最终得不偿失。试图想要用并发队列使同一时间尽可能多的执行任务，以提高效率，但实际却发现时间全部消耗在了线程切换上。</p>
<p>同样的道理就是类似下面这种代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_apply(count, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) &#123; </div><div class="line">	operation();</div><div class="line">&#125;</div><div class="line">//	这里使用 dispatch_apply 放入并发队列执行，如过 operation() 并不是非常耗时，不如直接使用 for loop</div></pre></td></tr></table></figure>
<p>总结一句话就是：如果发现实际的操作并不是非常耗时，就尽量不要用多线程去优化性能，否则大多数时间反而会消耗在线程切换上。</p>
<p>除此之外，使用这种模型时如果采用的是<code>并发队列 + barrier</code> + <code>信号量等待</code>，当大量并发的调用同步读写时，会造成死锁的问题。</p>
<p><strong>方式二：</strong> <code>并发队列</code> + <code>锁</code></p>
<ul>
<li>同步操作方式：<ul>
<li>读：当前线程直接加锁读。</li>
<li>写：当前线程直接加锁写。</li>
</ul>
</li>
<li>异步操作方式：<ul>
<li>读：异步到并发队列加锁读。</li>
<li>写：异步到并发队列加锁写。</li>
<li>其实就是异步到并发队列调用上然后调用同步读写。</li>
</ul>
</li>
</ul>
<p>Track、YYCache、PINCache 都采用这种线程安全模型，简单点说就是最终的读写操作都加高性能锁，保证每次最终的读写都互斥。相比于方式一，首先解决的问题就是同步操作的效率问题，因为都是在当前线程直接进行读写操作，没有任何线程调度，所以省去了开辟和线程切换的开销，同步读写性能远远高于方式一。其次解决了死锁的为题，即使大量并发调用同步读写时，因为没有了方式一的信号量等待使异步变同步，并不会造成线程资源饱和导致无法解锁信号量导致死锁的问题。</p>
<p>相比于方式一，方式二其实并不支持真正的并发同步读，因为最终读操作都是加锁的，所以每个读都互斥，而方式一是可以做到并发读。但是鉴于方式一的策略本身就有死锁的问题，并且这些并不能提高效率的并发操作也是建立在有死锁的风险上，所以方案并不可取。</p>
<p>Track 使用方式二，<code>MemoryCache</code> <code>DiskCache</code> 文件的类是线程安全的，<code>LinkList</code> 中的类是非线程安全的。<code>MemoryCache</code> <code>DiskCache</code> 文件中在使用 <code>LinkList</code> 中的类时做了线程安全封装。</p>
<h4 id="2-淘汰策略"><a href="#2-淘汰策略" class="headerlink" title="2.淘汰策略"></a>2.淘汰策略</h4><p>缓存的另一个功能是淘汰，每次设置数据完成后，都要对 count（总数） 和 cost（总内存占有量） 超出的部分进行移除，这两个淘汰功能所依据的条件是缓存对象的年龄，即 count 和 cost 淘汰每次从最老的数据开始移除。所以如何对对象年龄进行排序，也是决定性能好坏的因素之一。</p>
<p>在我读过的上面几个库中，实现淘汰的就只有 TM PIN 和 YY，TM 和 PIN 有 cost 和 date 淘汰，YY 和 Track 支持 count、cost、date 淘汰，实现方式分为两种如下：</p>
<p><strong>方式一：</strong>每次需要淘汰时重新排序，然后从最最老的数据开始移除</p>
<p>TM 和 PIN 各自有一个记录每个存储对象 date 的字典，每次写入之后的淘汰都是基于对这个数组重新排序然后开始末尾移除。</p>
<p>这样做的劣势很明显，就是每次都会重新进行排序，如果你在使用 PINMemoryCache 时，设置了 costLimit 属性，那么你会发现效率立刻从摩托变成了单车，只能用惨不忍睹来形容，并且随着存储对象数量增加，会变得越来越慢。</p>
<p><strong>方式二：</strong>使用链表也存储一份对象模型的引用，用于排序淘汰</p>
<p>链表数据结构的优势是在已知节点的前提下，插入、移动、和删除的时间复杂度都是O(1)，所以可以借助这个优势用实现 LRU。每次读取数据时，从字典中查询节点，然后在链表中将节点移到头部，写入数据后的淘汰就避免了重新根据年龄排序耗时的问题，直接从链表的末尾开始向前移除即可。</p>
<p>YYMemoryCache 和 Track.MemoryCache 都采用了这种方式，稍微有点不同的是，YY 的 cost 淘汰是异步到主线程调用的，Track 的 cost 是当前线程直接调用，这里各自的利弊就不多做评价了，各有各的想法吧，<a href="https://github.com/ibireme/YYCache/issues/54" target="_blank" rel="external">具体讨论可以看这里</a>。另外一点是很值得学习的，YY 在 count 淘汰时，是可选异步 release，设置 <code>releaseAsynchronously</code> 即可，这里需要提醒的是，我在小对象写入性能测试时，发现如果设置了 countLimit，YYMemoryCache 的效率就有明显下降，Profile 显示原因在异步到其他线程的过程消耗了一些性能，所以存储对象都为小对象且有 countLimit 时，建议将 releaseAsynchronously 设置为 NO。</p>
<h4 id="3-容器选取及对象存储模型"><a href="#3-容器选取及对象存储模型" class="headerlink" title="3.容器选取及对象存储模型"></a>3.容器选取及对象存储模型</h4><h5 id="容器选取"><a href="#容器选取" class="headerlink" title="容器选取"></a>容器选取</h5><p><strong>（1）Memory</strong></p>
<p>Memory 存储容器大致有这几种：NSCache，NSMutableDic，CFMutableDic</p>
<p>NSCache 和 Dic 的区别在于 NSCache 本身就是线程安全的，所以上层不再需要安全线程调度的保护，而 Dic 是非线程安全的。AwesomeCache 就是采用 NSCache 直接作为内存缓存，NSCache 的效率上面的统计图已经给出，这里就不多说了。我在写 Track 时，本身第一想法是用 Dictionary，但是发现它的效率没有 NSMutableDic 高，所以最终选取了 NSMutableDic 作为存储和查询容器，LinkedList 作为调整顺序的容器。</p>
<p><strong>（2）Disk</strong></p>
<p>毫无疑问，文件系统的效率远远小于数据库。由于对数据库并不是很了解，所以关于 Disk 部分就不做讨论了，可以去看 YY 的作者写的文章，里面对磁盘存储做了很好的讨论。</p>
<h5 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h5><p>这里想说的其实就是 TM 和 PIN 存在的另外一个性能问题，TM 和 PIN 在写入 Memory 时，除了写入本身存储 object 的 dictionary，还另外有两个字典 dates 和 costs。看源码中，会发现每次写入 object 时，都会对这三个字典写入一遍，性能分析时，发现写入的时间基本被这三个操作平分，性能立刻下降一大截。</p>
<p>Track 和 YY 则采用的是将 date 和 cost 都封装起来，每次写入或修改数据时，只用写或者读一次字典，这样性能就提升了很多。</p>
<h4 id="4-追求性能慎用闭包"><a href="#4-追求性能慎用闭包" class="headerlink" title="4. 追求性能慎用闭包"></a>4. 追求性能慎用闭包</h4><p>我在刚开始写 Track 的同步操作时，发现每次保证线程安全都需要加信号量锁，所以每次的代码都是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lock()</div><div class="line">...</div><div class="line">unlock()</div></pre></td></tr></table></figure>
<p>我觉得这样实在是太不优雅了，所以写了个这样的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func threadSafe(handler: () -&gt; Void) &#123;</div><div class="line">lock()</div><div class="line">handler()</div><div class="line">unlock()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后期我在优化性能时，发现闭包简直就是一个性能杀手，最后还是老老实实的前后调用加解锁函数。</p>
<h2 id="功能增加"><a href="#功能增加" class="headerlink" title="功能增加"></a>功能增加</h2><p>在写到 1.0 版本之后，我就在想，既然库是用 Swift 写的，如果没有一点 Swift 的功能，那岂不是等于抄袭别人写的代码然后翻译了一遍？所以就加入了些 Swift 的东西：</p>
<h4 id="支持-GeneratorType、SequenceType"><a href="#支持-GeneratorType、SequenceType" class="headerlink" title="支持 GeneratorType、SequenceType"></a>支持 GeneratorType、SequenceType</h4><p>我给 Track 中底层的的 LinkedList 和 LRU 实现了 <code>GeneratorType</code> 和 <code>SequenceType</code> 接口，这样 Track 上层封装后也支持了线程安全的 <code>GeneratorType</code> 和 <code>SequenceType</code>。这样就 Track 的 Cache、Memory、DiskMemory 都支持了 <code>for ... in</code> <code>map</code> <code>flapmap</code> <code>filter</code> 等一系列方法，功能更加强大啦。</p>
<p>这里值得一说的是，Disk 的 Generator 有实现的是 <code>FastGeneratorType</code>，这样使得 Cache 遍历时，只要 MemoryCache 能读出值，DiskCache 指针快速移动即可，效率并不会降低，当 MemoryCache 读不到内容时，便开始读 DiskCache，并且数据衔结正确。</p>
<h4 id="支持-Subscript"><a href="#支持-Subscript" class="headerlink" title="支持 Subscript"></a>支持 Subscript</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> cache: <span class="type">Cache</span> = <span class="type">Cache</span>.shareInstance</div><div class="line">cache[<span class="string">"key"</span>] = <span class="string">"value"</span></div><div class="line"><span class="keyword">let</span> <span class="number">_</span> = cache[<span class="string">"key"</span>]</div></pre></td></tr></table></figure>
<p>读写操作更方便。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>目前就功能和性能上来讲，Objective-C 的此类 Cache 库中，YYCache 绝对是最好的。Swift 中目前我还没有找同类功能较齐全的库，AwesomeCache 只拥有基本的功能，所以如果你在写 Swift 的项目，正巧需要一个 Cache，那么请使用 <a href="https://github.com/maquannene/Track" target="_blank" rel="external"><strong>Track</strong></a> 吧。</p>
<p><a href="https://github.com/maquannene/Track" target="_blank" rel="external"><strong>Track</strong></a> 还是花了我一些心思去尽量写好它，包括前期调研、后期加功能以及优化等等，以后仍将继续维护。</p>
<p>所以支持的话，就👍一下吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;开始萌生出要写这个 &lt;a href=&quot;https://github.com/maquannene/Track&quot;&gt;&lt;strong&gt;Cache&lt;/strong&gt;&lt;/a&gt; 念头，是想要练习一下 &lt;code&gt;Swift&lt;/code&gt; 这门语言，顺便实战 &lt;code&gt;GCD 达到多线程安全&lt;/code&gt; 和思考 &lt;code&gt;如何写一个易用的库&lt;/code&gt;。所以大概花了一个礼拜的时间完成了初级版，后续断断续续修补功能又花了两个礼拜，最终在 v1.2.0 的时候，达到了一个让我比较满意的程度。&lt;/p&gt;
&lt;p&gt;这个库没有用到特别高深的技巧，也没有特别复杂的算法，但是完成的过程让我学习到了很多东西，如果你想要实战 GCD 的基本用法、又或者是想要学习库基本的设计等等，建议读下去。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Git 学习笔记</title>
    <link href="http://yoursite.com/2016/02/23/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/02/23/Git-学习笔记/</id>
    <published>2016-02-23T05:47:53.000Z</published>
    <updated>2016-07-06T03:26:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Git-的产生"><a href="#一-Git-的产生" class="headerlink" title="一.Git 的产生"></a>一.Git 的产生</h2><p>作者：林纳斯·托瓦兹 （Linus Torvalds），Linux 的伟大的副产物</p>
<p style="text-align: center"><img src="http://img0.imgtn.bdimg.com/it/u=2504201466,3383861494&fm=21&gp=0.jpg" width="350"><br></p>

<p>Linus 在 1991 年创建了开源的 Linux 之后靠着开发者共同维护。</p>
<p>2002 以前 ，contributors 把源代码文件通过 diff 的方式发给 Linus，Linus 和 维护者 <code>手工方式</code> merge。</p>
<a id="more"></a>
<p>维护者受不了了，Linus 选择了 BitKeeper，并且很喜欢 BitKeeper.</p>
<p>理查德・斯托尔曼（Richard Stallman）自由软件倡导者，精神领袖，GNU计划创造者</p>
<p style="text-align: center"><img src="https://ss1.baidu.com/70cFfyinKgQFm2e88IuM_a/forum/pic/item/adaf2edda3cc7cd9684f8ce83e01213fb80e91a5.jpg" width="200"><br></p>

<p>并且有人开始对 BitKeeper 逆向，破解，BitKeeper 收回了 Linus 的免费使用权。</p>
<p>Linus 不得不要写一个自己的版本控制系统：</p>
<ul>
<li>1.速度优势，有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li>
<li>2.对非线性开发模式的强力支持（允许上千个并行开发的分支）</li>
<li>3.完全分布式</li>
<li>4.简单易用的设计，bullshit</li>
</ul>
<p>Linus 不到两周时间， C 写了一个分布式版本控制系统，1300 行左右，之后靠 contributors 去壮大。</p>
<p><strong>身世评价:</strong></p>
<p>亲爹：Linus <br><br>干爹：世界各地 contributors <br><br>外表：Source Tree, TortoiseGit 等等等 <br><br>内涵：<a href="http://pic002.cnblogs.com/img/1-2-3/201007/2010072023345292.png" target="_blank" rel="external">这里</a></p>
<h2 id="二-集中式-与-分布式"><a href="#二-集中式-与-分布式" class="headerlink" title="二. 集中式 与 分布式"></a>二. 集中式 与 分布式</h2><p>集中化的版本控制系统：SVN</p>
<p style="text-align: center"><img src="http://git.oschina.net/progit/figures/18333fig0102-tn.png" width="350"><br></p>

<p>单一的集中管理的服务器，保存所有文件的修订版本，协同者通过客户端连到这台服务器，查看提交记录或者进行提交。checkout 的只是某个版本的代码，没有任何版本信息记录。</p>
<p>分布式版本控制系统：Git</p>
<p style="text-align: center"><img src="http://git.oschina.net/progit/figures/18333fig0103-tn.png" width="350"><br></p>

<p>客户端并不只提取最新版本的文件快照，而是把代码仓库 <code>完整地镜像</code> 克隆（clone） 提取（fetch) 到本地</p>
<ul>
<li>1.分布式，去中心化 <br></li>
<li>2.本地提交 <br><ul>
<li>断网提交 <br></li>
<li>小步提交，颗粒化，跟踪代码时，更加细腻 <br></li>
<li>不用 sever，也可以进行版本控制 <br></li>
</ul>
</li>
<li>3.高速度，所以 commit，checkout 变得飞快 <br></li>
</ul>
<p><br></p>
<h2 id="三-Git-结构模型"><a href="#三-Git-结构模型" class="headerlink" title="三. Git 结构模型"></a>三. Git 结构模型</h2><p>为什么要理解 Git 结构模型？<br></p>
<ul>
<li>我 tmd 在哪？</li>
<li>我 tmd 的代码呢? </li>
<li>屏幕上的提示信息到底是 tmd 让我干嘛?</li>
</ul>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="四个区"></p>
<p><strong>两区两库：</strong></p>
<ul>
<li>Workspace：工作区，就是你在电脑里能看到的目录 <br></li>
<li>Index / Stage：暂存区，在暂存区的东西，才能 commit 到 Repository <br></li>
<li>Repository：本地仓库<br></li>
<li>Remote：远程仓库<br></li>
</ul>
<p><strong>六指令：</strong></p>
<ul>
<li>add：增加 <br></li>
<li>commit：提交 <br></li>
<li>push：推送 <br></li>
<li>fetch：拉取 <br></li>
<li>checkout：检出 <br></li>
<li>pull：fetch + merge <br></li>
</ul>
<p><br></p>
<h2 id="四-Git-命令讲解"><a href="#四-Git-命令讲解" class="headerlink" title="四. Git 命令讲解"></a>四. Git 命令讲解</h2><h3 id="1-init-clone"><a href="#1-init-clone" class="headerlink" title="1.init clone"></a>1.init clone</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//初始化 git</div><div class="line">git init 	</div><div class="line">//从服务器 clone repo，</div><div class="line">git clone</div></pre></td></tr></table></figure>
<h3 id="2-配置-Git"><a href="#2-配置-Git" class="headerlink" title="2.配置 Git"></a>2.配置 Git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//查看配置</div><div class="line">git config --global --list</div><div class="line">//编辑配置</div><div class="line">git config --global --edit</div><div class="line">	</div><div class="line">//设置提交人</div><div class="line">git config --global user.name &quot;John Doe&quot;</div><div class="line">//设置邮件</div><div class="line">git config --global user.email johndoe@example.com</div><div class="line">//设置编辑器</div><div class="line">git config --global core.editor emacs</div></pre></td></tr></table></figure>
<h3 id="3-add-stage"><a href="#3-add-stage" class="headerlink" title="3.add, stage"></a>3.add, stage</h3><p>从<code>工作区</code>选取一些代码快照，加入到<code>暂存区</code>，即将要<code>commit</code>的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//将 &lt;path&gt; 放到 暂存区</div><div class="line">git add &lt;path&gt;</div><div class="line">//将 改动的跟踪文件 放到暂存区，但是不包括 新增的 </div><div class="line">git add -u stages </div><div class="line">//将 所有 放到暂存区</div><div class="line">git add . </div><div class="line"></div><div class="line">//git add . 之后，想要移回工作区</div><div class="line">git reset</div><div class="line">//git add . 之后，如果又在工作区做了一些更改，但此时想要放弃工作区更改</div><div class="line">git checkout .</div></pre></td></tr></table></figure>
<ul>
<li>提问：为什么会有<code>暂存区</code>这个概念？</li>
<li>快照？</li>
</ul>
<h3 id="4-暂存-stash"><a href="#4-暂存-stash" class="headerlink" title="4.暂存 stash"></a>4.暂存 stash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//暂存当前工作区的变动</div><div class="line">git stash</div><div class="line">//暂存当前工作区的变动，并命名为&lt;name&gt;</div><div class="line">git save &quot;name&quot;</div><div class="line"></div><div class="line">//取出暂存，并删除</div><div class="line">git stash pop</div><div class="line"></div><div class="line">//取出暂存，不删除</div><div class="line">git stash apply &quot;name&quot;</div><div class="line"></div><div class="line">//列出暂存列表</div><div class="line">git stash list</div><div class="line"></div><div class="line">//删除暂存</div><div class="line">git stash drop &quot;name&quot;</div></pre></td></tr></table></figure>
<p><strong>高级用法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//操作片段</div><div class="line">git add -p</div><div class="line"></div><div class="line">y:	暂存此片</div><div class="line">n:	不暂存此片</div><div class="line">a:	暂存此片和剩余的片</div><div class="line">d:	不暂存和剩余的片</div><div class="line">?:	查看帮助</div><div class="line">q:	退出</div><div class="line">e:	手动编辑选择是否暂存</div><div class="line">s:	切片</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add -i</div></pre></td></tr></table></figure>
<h3 id="5-commit"><a href="#5-commit" class="headerlink" title="5.commit"></a>5.commit</h3><p>将<code>暂存区</code>的代码快照<code>提交</code>到<code>本地仓库</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git commit</div><div class="line">//直接将 工作区 的所有文件提交到`本地仓库`</div><div class="line">git commit -a</div><div class="line">//提交暂存区到仓库区</div><div class="line">git commit -m &quot;log&quot;</div></pre></td></tr></table></figure>
<p><strong>高级用法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//纠正最后历史</div><div class="line">git commit --amend</div><div class="line">//将 add 新的快照，追加最后到一次提交，并修改log</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>这样会更改历史</p>
<h3 id="6-remote"><a href="#6-remote" class="headerlink" title="6.remote"></a>6.remote</h3><p>远端，即远程服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">git remote</div><div class="line"></div><div class="line">//添加远程主机。</div><div class="line">git remote add &lt;主机名&gt; &lt;服务器地址&gt;</div><div class="line"></div><div class="line">//查看某个远程主机信息</div><div class="line">git remote show &lt;主机名&gt;</div><div class="line"></div><div class="line">git remote rm &lt;主机名&gt;</div><div class="line">git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</div></pre></td></tr></table></figure>
<h3 id="7-push"><a href="#7-push" class="headerlink" title="7.push"></a>7.push</h3><p>将本地的分支信息推向远端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push &lt;主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//将本地的主干推到远程主机，并建立追踪关系</div><div class="line">git push -u origin master:master</div><div class="line"></div><div class="line">//推送当前分支到追踪分支</div><div class="line">git push</div><div class="line"></div><div class="line">//强制覆盖推送 **改写历史***</div><div class="line">git push -f</div></pre></td></tr></table></figure>
<h3 id="8-pull"><a href="#8-pull" class="headerlink" title="8.pull"></a>8.pull</h3><p>pull = fetch + merge<br>pull –rebase = fetch + rebase</p>
<p>merge 优先尝试 fast-forward 模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</div><div class="line">git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</div></pre></td></tr></table></figure>
<h3 id="9-fetch"><a href="#9-fetch" class="headerlink" title="9.fetch"></a>9.fetch</h3><p>将远程仓库新的提交的拉取到本地仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch</div><div class="line">git fetch origin master</div></pre></td></tr></table></figure>
<h3 id="10-合并-merge-演合-rebase"><a href="#10-合并-merge-演合-rebase" class="headerlink" title="10.合并 merge 演合 rebase"></a>10.合并 merge 演合 rebase</h3><p><a href="http://pcottle.github.io/learnGitBranching/?NODEMO" target="_blank" rel="external">LearnGit</a></p>
<p>把一个分支中的修改整合到另一个分支的办法有两种：<code>merge</code> 和 <code>rebase</code></p>
<h4 id="a-合并-merge"><a href="#a-合并-merge" class="headerlink" title="a.合并 merge"></a>a.合并 merge</h4><p>把指定分支 branchX 合并到当前分支，如果不进行 fast-forward 模式，就会产生新的提交点。<br><br>若有冲突发生时，新的提交点为解决冲突记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge origin branchX</div></pre></td></tr></table></figure>
<p>合并前</p>
<p style="text-align: center"><img src="http://git.oschina.net/progit/figures/18333fig0327-tn.png" width="350"><br></p>

<p>合并后</p>
<p style="text-align: center"><img src="http://git.oschina.net/progit/figures/18333fig0328-tn.png" width="350"><br></p>

<p><strong>fast-forward 模式</strong></p>
<p style="text-align: center"><img src="http://nvie.com/img/merge-without-ff@2x.png" width="500"><br></p>

<h4 id="b-演合-rebase"><a href="#b-演合-rebase" class="headerlink" title="b.演合 rebase"></a>b.演合 rebase</h4><p>将当前分支和 branchX 产生分歧的 commit 点，重新在 branchX 演一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase branchX</div></pre></td></tr></table></figure>
<p>演合之前</p>
<p style="text-align: center"><img src="http://git.oschina.net/progit/figures/18333fig0327-tn.png" width="280"><br></p>

<p>演合之后<br></p>
<p style="text-align: center"><img src="http://git.oschina.net/progit/figures/18333fig0329-tn.png" width="350"><br></p>

<p>注意：尽量不要对已经推送到远程仓库的分支进行演合，否则再次推送时会产生冲突。永远不要改变历史。</p>
<p>神奇的演合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase --onto branchA branchB branchC</div></pre></td></tr></table></figure>
<h4 id="c-merge-和-rebase-的取舍"><a href="#c-merge-和-rebase-的取舍" class="headerlink" title="c.merge 和 rebase 的取舍"></a>c.merge 和 rebase 的取舍</h4><p>rebase: 保证了提交点的干净有序。<br><br>merge: 更加详细了记录了开发路线。</p>
<h3 id="10-后悔药-reset-revert-reflog"><a href="#10-后悔药-reset-revert-reflog" class="headerlink" title="10.后悔药 reset revert reflog"></a>10.后悔药 reset revert reflog</h3><h4 id="1-reset"><a href="#1-reset" class="headerlink" title="1.reset"></a>1.reset</h4><p>类似 SVN 的revert，将当前分支提交重置回某个提交点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset [commit]</div><div class="line">//--soft --mixed --hard</div></pre></td></tr></table></figure>
<p>注意：不要对已经在远程服务器的 commit 进行 reset</p>
<h4 id="2-revert"><a href="#2-revert" class="headerlink" title="2.revert"></a>2.revert</h4><p>对某一次提交做一次反向操作，并且提交创建一个新提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git revert [commit]</div></pre></td></tr></table></figure>
<h4 id="3-reflog"><a href="#3-reflog" class="headerlink" title="3.reflog"></a>3.reflog</h4><p>列出 HEAD 经历过的记录，神器~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure>
<h2 id="五-Git-开发模型–GitFlow"><a href="#五-Git-开发模型–GitFlow" class="headerlink" title="五. Git 开发模型–GitFlow"></a>五. Git 开发模型–GitFlow</h2><h3 id="1-branch"><a href="#1-branch" class="headerlink" title="1.branch"></a>1.branch</h3><p>Git 分支不同于 SVN，不是对文件拷贝的副本，而是快照，使用起来非常轻量级。这使得开发中对分支的 new，merge，delete 变得非常廉价，更好的支持并发型开发。开分支，就是新建一个指针而已。</p>
<p>分支的查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//列出所有本地分支</div><div class="line">git branch</div><div class="line"></div><div class="line">//列出所有远程分支</div><div class="line">git branch -r</div><div class="line"></div><div class="line">//列出所有分支</div><div class="line">git branch -a</div></pre></td></tr></table></figure>
<p>分支的新建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//新建分支 branchName</div><div class="line">git branch [branchName]</div><div class="line"></div><div class="line">//新建分支 branchName 并且切换</div><div class="line">git checkout -b [branchName]</div><div class="line"></div><div class="line">//从一个 commit 点新建一条分支 branchName</div><div class="line">git branch [branchName] [commit]</div></pre></td></tr></table></figure>
<p>分支的切换 checkout 功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//切换分支</div><div class="line">git checkout [branchName]</div><div class="line">//移动 head</div><div class="line">git checkout [commit]</div><div class="line">//将追踪的文件重置为上一次 commit 的内容</div><div class="line">git checkout &lt;fileName&gt;</div></pre></td></tr></table></figure>
<h3 id="2-GitFlow"><a href="#2-GitFlow" class="headerlink" title="2.GitFlow"></a>2.GitFlow</h3><p style="text-align: center"><img src="http://nvie.com/img/git-model@2x.png" width="600"><br></p>

<h2 id="六-辅助利器"><a href="#六-辅助利器" class="headerlink" title="六. 辅助利器"></a>六. 辅助利器</h2><h3 id="1-Zsh"><a href="#1-Zsh" class="headerlink" title="1.Zsh"></a>1.<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">Zsh</a></h3><h3 id="2-GitDiff"><a href="#2-GitDiff" class="headerlink" title="2.GitDiff"></a>2.<a href="https://github.com/johnno1962/GitDiff" target="_blank" rel="external">GitDiff</a></h3><h2 id="七-扩展"><a href="#七-扩展" class="headerlink" title="七. 扩展"></a>七. 扩展</h2><h3 id="1-git-config"><a href="#1-git-config" class="headerlink" title="1.git config"></a>1.git config</h3><h3 id="2-git-rebase-i"><a href="#2-git-rebase-i" class="headerlink" title="2.git rebase -i"></a>2.git rebase -i</h3><p>修改历史的一个方法，提供了重写 commit，合并 commit，更改 commit 顺序等功能。之后有时间补上这一部分。</p>
<h3 id="3-cherry-pick"><a href="#3-cherry-pick" class="headerlink" title="3.cherry-pick"></a>3.cherry-pick</h3><p>将一个提交点重新应用到当前分支，此时是一个新的提交号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git cherry-pick [commit]</div></pre></td></tr></table></figure>
<p><del>注意：永远不要 cherry-pick 已推送到远端的 commit，否则再次推送时会产生冲突。</del><br>这句话是我错误的认知，删去。cherry-pick 的提交点再次合并回去之后，不会引起冲突。</p>
<h3 id="4-gitignore"><a href="#4-gitignore" class="headerlink" title="4..gitignore"></a>4..gitignore</h3><p>这个可以参考这个<strong><a href="https://github.com/github/gitignore" target="_blank" rel="external">开源项目</a></strong></p>
<h3 id="5-alias"><a href="#5-alias" class="headerlink" title="5.alias"></a>5.alias</h3><p>alias 我用的不多，因为不想太依赖这个东西，用的最频繁的就下面一个：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lg = <span class="built_in">log</span> --color --graph --pretty=format:<span class="string">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit</div></pre></td></tr></table></figure>
<h3 id="6-ssh"><a href="#6-ssh" class="headerlink" title="6.ssh"></a>6.ssh</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-Git-的产生&quot;&gt;&lt;a href=&quot;#一-Git-的产生&quot; class=&quot;headerlink&quot; title=&quot;一.Git 的产生&quot;&gt;&lt;/a&gt;一.Git 的产生&lt;/h2&gt;&lt;p&gt;作者：林纳斯·托瓦兹 （Linus Torvalds），Linux 的伟大的副产物&lt;/p&gt;
&lt;p style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;http://img0.imgtn.bdimg.com/it/u=2504201466,3383861494&amp;fm=21&amp;gp=0.jpg&quot; width = &quot;350&quot;/&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Linus 在 1991 年创建了开源的 Linux 之后靠着开发者共同维护。&lt;/p&gt;
&lt;p&gt;2002 以前 ，contributors 把源代码文件通过 diff 的方式发给 Linus，Linus 和 维护者 &lt;code&gt;手工方式&lt;/code&gt; merge。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中 APP 回到前台通知的选择</title>
    <link href="http://yoursite.com/2016/02/19/iOS-%E4%B8%AD-APP-%E5%9B%9E%E5%88%B0%E5%89%8D%E5%8F%B0%E9%80%9A%E7%9F%A5%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <id>http://yoursite.com/2016/02/19/iOS-中-APP-回到前台通知的选择/</id>
    <published>2016-02-19T07:01:32.000Z</published>
    <updated>2016-06-20T12:24:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>UIApplicationWillEnterForegroundNotification</strong><br>iOS 中检测 APP 回到前台一般使用通知策略，正常的情况下我们选择此条通知，这条通知的接受时机是 app 将要进入前台。<br><br><strong>UIApplicationDidBecomeActiveNotification</strong><br>但是也有人会选择这一条通知，从名称上来看，此通知的接受时机是：app 已经变为激活状态。<br><a id="more"></a><br>我在做一个需求时，在这两条通知的选择上除了点小错。<br>需求是：当<code>程序启动</code>或者<code>程序从后台切到前台</code>时，显示输入密码界面。<br>于是我监听这个通知 <code>UIApplicationWillEnterForegroundNotification</code>，然后在 selector 中去 show 密码界面。<br>结果发现如果程序启动时，这个通知并不会被调到，之后发现有另外一条通知，<code>UIApplicationDidBecomeActiveNotification</code>。<br>这个通知相比于 <code>UIApplicationWillEnterForegroundNotification</code> 在启动的时候是会发送的。<br><br>总结：<br>UIApplicationWillEnterForegroundNotification：只有回到前台，启动 app 不算<br>UIApplicationDidBecomeActiveNotification：回到前台 + 启动 app<br><br>如果两条通知都监听，那么 UIApplicationWillEnterForegroundNotification 是要早于 UIApplicationDidBecomeActiveNotification。<br><br>简单的知识点，有时候还是存在疏漏的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;UIApplicationWillEnterForegroundNotification&lt;/strong&gt;&lt;br&gt;iOS 中检测 APP 回到前台一般使用通知策略，正常的情况下我们选择此条通知，这条通知的接受时机是 app 将要进入前台。&lt;/br&gt;&lt;br&gt;&lt;strong&gt;UIApplicationDidBecomeActiveNotification&lt;/strong&gt;&lt;br&gt;但是也有人会选择这一条通知，从名称上来看，此通知的接受时机是：app 已经变为激活状态。&lt;br&gt;
    
    </summary>
    
      <category term="技术探讨" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E8%AE%A8/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>博客改用 hexo 托管到 github 爬坑之旅</title>
    <link href="http://yoursite.com/2016/01/08/%E5%8D%9A%E5%AE%A2%E6%94%B9%E7%94%A8%20hexo%20%E6%89%98%E7%AE%A1%E5%88%B0%20github%20%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2016/01/08/博客改用 hexo 托管到 github 爬坑之旅/</id>
    <published>2016-01-08T05:17:41.000Z</published>
    <updated>2016-01-13T11:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近又蛋疼了，这个博客原本是用 Octopress 搭建的，搭建过程 <strong><a href="http://maquannene.github.io/2015/11/20/2015-11-20-xin-bo-ke-da-jian-bi-ji/" target="_blank" rel="external">详见这里</a></strong>。直到最近在知乎上看到 <strong><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">这个提问</a></strong>，我又决定把博客从 Octopress 转为 Hexo 了。</p>
<p>本来想在这篇文章记录一下迁移过来的流程，但网上关于 hexo 博客的搭建技术贴实在太多了，所以考虑之后，不打算写这个流程，毕竟意义也不大，在这里贴一篇我觉得写得比较好的，如果你需要基于 hexo 搭建个人博客 <strong><a href="http://blog.hjtxxx.com/2015/08/13/Hexo-%E4%B8%80-%EF%BC%9A%E5%9C%A8GitHub%E4%B8%8A%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2" target="_blank" rel="external">详见这里</a></strong></p>
<p>下面最主要就是总结一下我遇到的问题，关于博客托管到 github 的问题。声明一下，我是完全不懂 js 网页这些东西的，所以下面写的东西，也只是我个人层面上的理解，所以如果有什么地方说的有问题，轻喷。</p>
<a id="more"></a>
<p>在讲述我遇到的坑的问题之前，有必要先讲解一下 hexo 工程的文件划分。</p>
<p>hexo 的源码目录大概是这样：<br><img src="http://ww4.sinaimg.cn/large/65312d9agw1ezxy3ebuqjj20b408twf1.jpg" alt="hexo目录结构"><br><br><strong>public</strong><br>在 clone 了 hexo 项目之后，应该是是没有 <code>public</code> 这个文件夹的。当执行 <code>hexo g</code> 时（g 是 generate 的缩写，意思是生成），hexo 会生成 <code>public</code> 这个文件夹和里面的文件，所以 <code>/public</code> 文件夹中放置的文件，自然就是最终网页显示需要的静态网页文件，这个是因每个人博客的内容不同而不同，所以源码中不必要存在这个文件夹，这一点在我们查看 .gitignore 时会发现，这个文件夹是被忽略的，并不需要上传。</p>
<p>当我们写好博客之后，执行 <code>hexo g</code> 生成网页文件，然后执行 <code>hexo d</code>，就会将 <code>public</code> 里面的文件 post 在 <code>github</code> 的 username.github.com 这个仓库，之后就能访问你的博客了。<br><br><strong>source</strong><br>这个文件夹是用来存放你博客的文本内容。<br>打开 <code>/source</code> 之后，发现有一个 <code>_post</code> 文件夹，此文件夹中就是存放你所有博文内容的文件夹，博文是用markdown 来写的，写好之后，放入 <code>_post</code> 即可。除此之外 <code>source</code> 还可以加入 <code>about</code> 等文件夹，用来写 <code>关于我</code> 等页面的文本内容。<br><br><strong>theme</strong><br>theme 自然就是放置博客主题的文件夹，比如源生的主题：<code>landscape</code>。自己通过 clone 安装的三方主题也会出现在这里。<br><br><strong>_config.yml 等</strong><br>剩下的这些就是配置文件等，除此之外其他的我也不知道是些什么东西。<br><br>在了解了 hexo 整体的目录结构之后，就具体讲一讲让我蛋疼的坑。</p>
<p>我在 clone 完 hexo 这个项目之后，发现主题不是很好看，就想换一个主题，于是乎我去找了个漂亮的第三方主题并且 clone 到了 <code>/theme</code> 文件夹下。然后发现这个主题需要做一些配置，所以就在 <code>/theme/xxx主题/..</code> 怒改造了一下，之后<code>hexo g</code> <code>hexo s</code>， 然后预览了一下，嗯~~还不错，于是 <code>hexo d</code> 将博客的静态文件 push 到了我的 github 的 maquannene.github.com 仓库的 master 分支上面。最后根据当时使用 Octopress 的经验，我又将 hexo 的源码我也要推到 maquannene.github.com 的另一个分支，比如 hexo。下一次换个新环境写博客时，只用将 clone 一下 hexo 这个分支，然后写写博文，<code>hexo g</code> <code>hexo d</code> 就ok了。<br><br>在确定已经将 hexo 文件 post 到 github 之后，我将本地的 hexo 文件夹直接删掉，准备尝试一下重新拉取自己 github 上 hexo 项目，继续写博客的流程。</p>
<p>如上面所述，clone 自己 github 的 hexo，执行 <code>hexo g</code>，这是我发现报了很多 WARNING：<br><img src="http://ww3.sinaimg.cn/large/65312d9agw1ezy032rvmej20b403zt9g.jpg" alt="无主题生成错误"></p>
<p>在执行 <code>hexo s</code> 后访问：<code>localhost：4000</code> 发现什么也没有显示。<br>于是我检查了一遍 clone 下来的 hexo，发现是我先前安装的的 <code>yelee</code> 主题文件夹中什么文件都没有，默认的主题 <code>landscape</code> 却存在。我以为是 github clone 出了问题，然后我打开我 github 的 hexo 项目，发现 theme/yelee 文件夹是黑色的：<br><img src="http://ww4.sinaimg.cn/large/65312d9agw1ezy032cl8uj20b406ct94.jpg" alt="无主题文件"></p>
<p>这时候我意识到，我在 push hexo 时，并没有将所有的文件 push 上去，于是我默默地从回收站找回来删掉的那个 hexo，仔细查看为什么主题没有被 push 上去。我又尝试在更改了一下 <code>/yelee</code> 中的文件，这时，我在 iterminal 中输入 <code>git diff</code> ，看到了如下信息：<br><img src="http://ww2.sinaimg.cn/large/65312d9agw1ezy0323yb3j20dw03cwf3.jpg" alt="gitdiff子repo"></p>
<p>用了一段时间 git，但是从来没有见过 <code>Subproject</code> 这个关键字，于是 google 一下，发现原来是一个被 git 版本管理的 repo 中的某个文件夹被另外一个 git 进行版本管理着，于是我进到 <code>/theme/yelee</code> 中，输入 <code>ls -a</code> 发现真有一个 <code>.git</code> 文件，然后又输入 <code>git remote -v</code>，发现当前 <code>yelee</code> 主题仓库的 origin 是另外一个远程主机，而不是我自己 github 博客 repo 的主机，恍然大悟，原来在 clone yelee 时，也将 <code>.git</code> 文件 clone 了下来，那么这个 repo 自然就被原来的 git 版本管理。所以当我处在外面文件夹的版本控制中进行 add commit push 时，对里面受另外一个版本控制的文件是无效的。<br><br>到这里，终于弄明白为什么 yelee 没有被 push 上去了。<br>于是我在我的 github 中创建了一个主题仓库，并且删除了 yelee 的 origin remote，添加新的 origin 为自己的主题仓库地址，最后将 clone 下来的被自己改过的主题 push 到了我自己的主题 repo 中。同样我有建立了一个 hexo 的仓库，将 hexo 推到了 <code>hexo</code> repo 中，而不是 <code>xxx.github.com</code> repo 的 hexo 分支中。s而当执行 <code>hexo d</code> 时，静态网页仍然部署到的是 xxx.github.com 仓库的 master 分支。<br><br>那么目前为止，我将原来的一个仓库两个分支（ hexo 源码分支，静态网页分支）变成了三个仓库（hexo 源码仓库：<code>hexo</code>，静态网页仓库：<code>xxx.github.com</code>，主题仓库：<code>yelee-theme</code>），每个仓库有自己的主分支。<br><br>这样，我下次拉取博客时，不但需要将 hexo repo 克隆下来，并且还要将自己的主题也从主题仓库中克隆下来。当我更改了博文时，就 push 到 <code>hexo</code> repo ，改了主题时，就 push 到 <code>yelee-theme</code> repo 中，而 <code>hexo d</code> 部署时，会自动 push 到 <code>xxx.github.com</code> repo 中。<br><br>最后这样的结构看来是比原来清晰多了，哎，还是自己将 branch 分支这个概念乱用了，如果是定位不同的文件，就要用 repo 仓库进行区分，而不是推到不同的分支，这是不符合 git 的分支理念的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又蛋疼了，这个博客原本是用 Octopress 搭建的，搭建过程 &lt;strong&gt;&lt;a href=&quot;http://maquannene.github.io/2015/11/20/2015-11-20-xin-bo-ke-da-jian-bi-ji/&quot;&gt;详见这里&lt;/a&gt;&lt;/strong&gt;。直到最近在知乎上看到 &lt;strong&gt;&lt;a href=&quot;https://www.zhihu.com/question/24422335&quot;&gt;这个提问&lt;/a&gt;&lt;/strong&gt;，我又决定把博客从 Octopress 转为 Hexo 了。&lt;/p&gt;
&lt;p&gt;本来想在这篇文章记录一下迁移过来的流程，但网上关于 hexo 博客的搭建技术贴实在太多了，所以考虑之后，不打算写这个流程，毕竟意义也不大，在这里贴一篇我觉得写得比较好的，如果你需要基于 hexo 搭建个人博客 &lt;strong&gt;&lt;a href=&quot;http://blog.hjtxxx.com/2015/08/13/Hexo-%E4%B8%80-%EF%BC%9A%E5%9C%A8GitHub%E4%B8%8A%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2&quot;&gt;详见这里&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面最主要就是总结一下我遇到的问题，关于博客托管到 github 的问题。声明一下，我是完全不懂 js 网页这些东西的，所以下面写的东西，也只是我个人层面上的理解，所以如果有什么地方说的有问题，轻喷。&lt;/p&gt;
    
    </summary>
    
      <category term="装逼指南" scheme="http://yoursite.com/categories/%E8%A3%85%E9%80%BC%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>从 Self-Mananger 说开去</title>
    <link href="http://yoursite.com/2016/01/05/2016-01-05-cong-self-manangershuo-kai-qu/"/>
    <id>http://yoursite.com/2016/01/05/2016-01-05-cong-self-manangershuo-kai-qu/</id>
    <published>2016-01-05T01:28:24.000Z</published>
    <updated>2016-01-13T11:48:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵看了一片文章，是来自于百度的阳神（Sunnyxx）写的 <a href="http://blog.sunnyxx.com/2015/12/19/self-manager-pattern-in-ios/" target="_blank" rel="external">iOS 开发中的 Self-Manager 模式</a>，对于文章中所描写的使用 Self-Mananger 的场景，我在平时的开发中也遇到过很多次，所以在这里就举几个例子写一下我对于此类问题自己的一些看法。</p>
<a id="more"></a>
<h4 id="从具体例子出发："><a href="#从具体例子出发：" class="headerlink" title="从具体例子出发："></a>从具体例子出发：</h4><p>关与对 View 写类别，并将原属于 Controller 中的业务逻辑东西移入类别中，这里拿一个我最近写的一个功能做例子：</p>
<p><img src="http://ww2.sinaimg.cn/large/65312d9agw1ezoh83xpe9j206y05cdfv.jpg" alt="密码锁"></p>
<p>这是一个输入验证密码的 View，他的功能是当用户输入密码时，图中的圆圈填充记录，当输入位数到 4 位时，进行密码验证。</p>
<p>那么理所当然这个 View 要保持纯净，即 View 类中不包含业务逻辑，并且能提供复用、易拆除等特点，我们需要将验证的事件回调出去，所以这个类大概是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">PwdVerifyViewDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)pwdVerifyView:(PwdVerifyView *)view canThroughPasswordVerify:(<span class="built_in">NSString</span> *)password;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PwdVerifyView</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;PwdVerifyViewDelegate&gt; delegate;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们需要在一个 ControllerA 中用到这个 PwdVerifyView时，只需要实例化 PwdVerifyView 并且将 pwdVerifyView.delegate 指向 ControllerA 并实现代理即可。</p>
<p>如果想要将 pwdVerifyView.delegate 的逻辑单独分离出去，只需要对 ControllerA 写一个 category 即 ControllerA（PwdVerifyView），让其实现代理即可。</p>
<p>所以我当时也就理所当然的在阳神的博客下面留下了这段话：</p>
<p><img src="http://ww1.sinaimg.cn/large/65312d9agw1ezoh84gkawj21r005m75o.jpg" alt="评论"></p>
<h4 id="忽略的点："><a href="#忽略的点：" class="headerlink" title="忽略的点："></a>忽略的点：</h4><p>后来我发现我忽略了 sunnyxx 所说蛋疼问题的第二点，比如类似这样的 View 可能出现在工程的其他几个地方，并且每次需要校验的密码时一致的，即代理中校验的过程是一致的，那么我们不得不在每个实例化这个 View 的控制类中去重复实现相同的代理和处理逻辑，此时 Self-Mananger 这种模式就开始发挥威力了。</p>
<h4 id="改善："><a href="#改善：" class="headerlink" title="改善："></a>改善：</h4><p>接下来，我们对这个 PwdVerifyView 开一个 Category，叫 PwdVerifyView（SelfManager），且自己实现自己的代理，大致代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//	类方法实例</span></div><div class="line">+ (<span class="keyword">instancetype</span>)PwdVerifyViewWithSelfMananger</div><div class="line">&#123;</div><div class="line">    PwdVerfiyView *pwdVerfiyView = [[PwdVerfiyView alloc] init];</div><div class="line">    pwdVerfiyView.delegate = pwdVerfiyView;</div><div class="line">    <span class="keyword">return</span> pwdVerfiyView;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)pwdVerifyView:(PwdVerifyView *)view canThroughPasswordVerify:(<span class="built_in">NSString</span> *)password</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    利用 SSKeychain 中存的密码验证</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里我以为万事大吉了，但是 <strong>这个世界在变，而人的心也在变，产品也在变</strong>，直到有一天他们告诉我有5个地方需要处理一套密码验证逻辑，6个地方需要处理另一套验证逻辑（夸张一下），当时我想，好办，再开一个 PwdVerifyView（SelfManager2），将代理实现的验证过程改一改就哦了。正当我要开始时，我抖了一个机灵，不对啊，如果我要再写个类别并且重写了那个代理方法，当文件加入工程中时，就会把先加入工程中的那个类别中的代理方法覆盖了，我百思不得骑姐之后想了下，如果代理会覆盖，那我就不用代理，用 block 回调。</p>
<p><strong>block 和 delegate 回调方式的最大区别在于：</strong>block 回调是离散式的，哪里创建回调哪里；delegate 可以多对一可聚合，即多个相同组件代理可以指向同一个对象，并调用同一个方法，具体处理流程可在方法中做区分。</p>
<p>delegate 是基于方法的，那么 category 中重复实现接口就会被覆盖，所以最后我将 PwdVerifyView 改成了 block 回调，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PwdVerifyView</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">BOOL</span> (^canThroughPasswordVerify) (PwdVerifyView *pwdVerifyView, <span class="built_in">NSString</span> *passwrod);</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>此时我也不用新开一个类别，只用将原来类别中代理回调改为 block 回调，并且新增一个类方法创建另一种验证方式的 PwdVerifyView 即可，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)PwdVerifyViewWithSelfManangerInXXXCondition</div><div class="line">&#123;</div><div class="line">    PwdVerfiyView *pwdVerfiyView = [[PwdVerfiyView alloc] init];</div><div class="line">    pwdVerifyView.canThroughPasswordVerify = ^(PwdVerifyView *pwdVerifyView, <span class="built_in">NSString</span> *password) &#123;</div><div class="line">    	...</div><div class="line">    	xxxCondition 条件下利用 SSKeychain 中存的另一种密码验证</div><div class="line">    	...</div><div class="line">        <span class="keyword">return</span> xxx;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> pwdVerfiyView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="继续思考："><a href="#继续思考：" class="headerlink" title="继续思考："></a>继续思考：</h4><p>那么这种用法到底有什么局限性呢？</p>
<p>我发现如果一旦将整个流程规制在类别中，那基本算是和外界断了耦合；换句话说外界用这个类别的类方法，整个密码验证逻辑和外界是没有任何关系的。但是如果我们有需求验证的最终密码由外面提供，那么我们就可以给类构造方法添加参数，类似下面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)PwdVerifyViewWithSelfMananger:(<span class="built_in">NSString</span> *)pwd</div><div class="line">&#123;</div><div class="line">    PwdVerfiyView *pwdVerfiyView = [[PwdVerfiyView alloc] init];</div><div class="line">    pwdVerifyView.canThroughPasswordVerify = ^(PwdVerifyView *pwdVerifyView, <span class="built_in">NSString</span> *password) &#123;</div><div class="line">    	...</div><div class="line">    	（<span class="number">1</span>）利用传进来的 pwd 和 password 进行对比运算进行验证等</div><div class="line">    	（<span class="number">2</span>）当然不只有对比而已，可能还要操控 pwdVerifyView 进行错误提示等等。</div><div class="line">    	...</div><div class="line">        <span class="keyword">return</span> xxx;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> pwdVerfiyView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>pwd 可能处处不同，所以加参数由外检提供，属于耦合部分；而（1）（2）流程都属于公有行为，即处处相同，属于无耦合部分。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>经过对这个类一系列的演化，最终总结出以下几点：<br><br>1.尽可能将公有的逻辑放在一个地方，只写一次，用时每次调用即可，如上述相同的验证流程；<br><br>2.有耦合条件时，有外接提供，另加参数，可提供不同的类构造方法；<br><br>3.针对于离散式回调行为 block 比 delegate 更适合；<br><br>4.具体应该将一个模块封装到多高的可复用程度？上面的代码中，复用可能程度最高的是 PwdVerfiyView，这一部分是不依赖业务逻辑的，可随处复用；接下来是 PwdVerfiyView（SelfMananger），这一部分在工程中可复用；最后把不可复用的部分由外界提供；拥有这样的代码结构，我们在后期拆除代码时才能轻松的一层一层剥掉不需要的，去用需要的部分；<br><br>其实回头看看，这个问题并没有什么好研究的，也没什么高端技巧，就是我个人对于代码的矫情程度罢了罢了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵看了一片文章，是来自于百度的阳神（Sunnyxx）写的 &lt;a href=&quot;http://blog.sunnyxx.com/2015/12/19/self-manager-pattern-in-ios/&quot;&gt;iOS 开发中的 Self-Manager 模式&lt;/a&gt;，对于文章中所描写的使用 Self-Mananger 的场景，我在平时的开发中也遇到过很多次，所以在这里就举几个例子写一下我对于此类问题自己的一些看法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术探讨" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E8%AE%A8/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title> MRC 下使用 Block 中的对象被释放，野指针的处理</title>
    <link href="http://yoursite.com/2015/11/20/2015-11-20-the-resolution-of-block-nil-in-mrc/"/>
    <id>http://yoursite.com/2015/11/20/2015-11-20-the-resolution-of-block-nil-in-mrc/</id>
    <published>2015-11-20T09:44:56.000Z</published>
    <updated>2016-06-21T01:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 开发目前已是全民 ARC 的时代，而且苹果的新语言 swift 也只是 ARC的。ARC 环境中，一个 var 声明的是<code>__weak</code>，那么当这个 var 不再被 <code>__strong</code> 引用时，这个 <code>__weak</code> 的 var 就会自动变成 nil，所以大多数情况下不必担心因为没有置 nil 而导致的野指针崩溃。</p>
<p>但是，如果仍旧使用的是MRC，那么就不得不面对这个问题：<br>网络请求中，大量使用到 block，如果当 block 中引用到了一个被 <code>__block</code> 关键字声明的变量，并且在这个 block 被回调的时候，这个 var 已经被释放了，那么此时 block 中捕获的这个 var 就成为了一个野指针。Objective-C 中，向一个 nil 的对象发送消息是不会崩溃的，但是对一个野指针发送对象是必然崩溃的。</p>
<p>那么问题来了，如何在 MRC 下避免这种崩溃的发生。<br><a id="more"></a></p>
<h4 id="方法一：将-MRC-的文件改成-ARC-的"><a href="#方法一：将-MRC-的文件改成-ARC-的" class="headerlink" title="方法一：将 MRC 的文件改成 ARC 的"></a>方法一：将 MRC 的文件改成 ARC 的</h4><p>如果都是这样改，那我还写这篇干个毛啊。关键在于，工程中MRC的文件太多了，行数少的一百多行还能改，上千行的就放弃吧。</p>
<h4 id="方法二：搞一个类似于全局的-NSMutblMeSet-去暂存可能会出现问题中所描述的-var"><a href="#方法二：搞一个类似于全局的-NSMutblMeSet-去暂存可能会出现问题中所描述的-var" class="headerlink" title="方法二：搞一个类似于全局的 NSMutblMeSet 去暂存可能会出现问题中所描述的 var"></a>方法二：搞一个类似于全局的 NSMutblMeSet 去暂存可能会出现问题中所描述的 var</h4><p>首先这个 NSMutblMeSet 可以是个全局静态的变量，可以是个属于 AppDelegate 的 var and so on，无所谓。如果一个对象涉及到问题中描述的可能会变成野指针的用法，那么这个对象初始化的时候，就注册进这个NSMutblMeSet；delloc时，就从 NSMutblMeSet 中 remove。在block中使用时，先对对象进行是否存在检查，如果存在就向可以向这个对象发送消息，不存在就返回等等。<br>这其实是我在网上找到了一种方法，这种方法是可以解决想野指针发送消息引起的崩溃，但是并不是我想要的解决方法，装逼点说，就是我觉得这个方法不够优雅。</p>
<h4 id="方法三：实现类似-ARC-下-weak-的功能，被释放时自动置为-nil"><a href="#方法三：实现类似-ARC-下-weak-的功能，被释放时自动置为-nil" class="headerlink" title="方法三：实现类似 ARC 下 __weak 的功能，被释放时自动置为 nil"></a>方法三：实现类似 ARC 下 __weak 的功能，被释放时自动置为 nil</h4><p>前一阵看到了一篇文章，讲的是 ARC <strong>weak 自动设置为 nil 的原理。所以我就在想，如果仿照 ARC `</strong>weak<code>原理应该可以实现。
所以就大致将这个原理写了一下并且做了封装，其实非常简单，就是</code>关联<code>+</code>block`。</p>
<h5 id="创建一个叫MMAutoNilHelper的类"><a href="#创建一个叫MMAutoNilHelper的类" class="headerlink" title="创建一个叫MMAutoNilHelper的类"></a>创建一个叫<code>MMAutoNilHelper</code>的类</h5><p>这个类只有一个属性，并且只干一件事情。这个属性是一个 <code>block</code>，类型为<code>void(^MMAutoNilBlock)(void)</code>;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^MMAutoNilBlock)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MMAutoNilHelper</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) MMAutoNilBlock autoNilBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>其次：这个类只干的一件事情就是在自己 dealloc 的时候调用这个 block ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="keyword">if</span> (_autoNilBlock) &#123;</div><div class="line">        _autoNilBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.autoNilBlock = <span class="literal">nil</span>;</div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="怎么用MMAutoNilHelper这个类"><a href="#怎么用MMAutoNilHelper这个类" class="headerlink" title="怎么用MMAutoNilHelper这个类"></a>怎么用<code>MMAutoNilHelper</code>这个类</h5><p>我们的目的在于，在某一个var被释放时，指向这个 var 的 __block 型 var 都自动变为 nil ，那么我们就可以借助这个<code>autoNilBlock</code>来帮助我们完成这个事情，具体操作如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">typeof</span>(<span class="keyword">self</span>) bSelf = <span class="keyword">self</span>;</div><div class="line">MMAutoNilHelper *autoNilHelper = [[MMAutoNilHelper alloc] init];</div><div class="line">autoNilHelper.autoNilBlock = ^&#123;</div><div class="line">    bSelf = <span class="literal">nil</span>;</div><div class="line">&#125;;</div><div class="line">_setAssociatedObject(bSelf, &amp;autoNilHelper, autoNilHelper, _ASSOCIATION_RETAIN);</div><div class="line">[autoNilHelper release];</div></pre></td></tr></table></figure>
<p>看过代码之后，其实道理很简单易懂了吧。<br>假如上面的 <code>bSelf</code> 随时都有被释放的可能，那么我们实例一个 <code>MMAutoNilHelper</code> 对象，并且将这个对象关联到 <code>bSelf</code>（就是自己）上，当bSelf被释放的时候，<code>autoNilHelper</code> 也会被释放，<code>autoNilHelper</code> 的 <code>dealloc</code> 方法就会被调用，此时，<code>_autoNilBlock()</code> 就会被调用，bSelf就会被设置为了 nil。这时，无论哪个 block 捕获了 bSelf，bSelf 都会变成 nil，这样就不会出现野指针的现象了。</p>
<h5 id="更加优雅一点"><a href="#更加优雅一点" class="headerlink" title="更加优雅一点"></a>更加优雅一点</h5><p>如果每次都要写那么多第二步的代码，那岂不是太啰嗦，所以可以创建一个 NSObject 的 category，将第二步的代码放在 category 的一个方法中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)MMMrcWeak:(MMAutoNilConfigureBlock)autoNilConfigureBlock &#123;</div><div class="line">    MMAutoNilHelper *autoNilHelper = [[MMAutoNilHelper alloc] init];</div><div class="line">    <span class="comment">//	注意这里，这里不再是直接给autoNilHelper.autoNilBlock赋值，而是用一个 configureBlock 构造 autoNilHelper</span></div><div class="line">    <span class="keyword">if</span> (autoNilConfigureBlock) &#123;</div><div class="line">        autoNilConfigureBlock(autoNilHelper);</div><div class="line">    &#125;</div><div class="line">    [autoNilHelper release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，将配置配置 autoNilHelper 写成宏：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define MMMrcWeakObserver(x)                                                        \</span></div><div class="line"><span class="keyword">void</span> * ptr = &amp;x;                                                                    \</div><div class="line">[x MMMrcWeak:^(MMAutoNilHelper *autoNilHelper) &#123;                                    \</div><div class="line">	<span class="comment">//	注意这里关联的地址是取 x 的地址，解除关联也是利用这个 ptr</span></div><div class="line">    objc_setAssociatedObject(x, ptr, autoNilHelper, OBJC_ASSOCIATION_RETAIN);       \</div><div class="line">    <span class="comment">//	设置自动置 nil 的block</span></div><div class="line">    autoNilHelper.autoNilBlock = ^&#123;                                                 \</div><div class="line">        bSelf = <span class="literal">nil</span>;                                                                \</div><div class="line">    &#125;;                                                                              \</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>此时如果我们在碰到想要 bSelf 自动置为 nil，就只用写一句话 <code>MMMrcWeakObserver(bSelf)</code> 即可。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">typeof</span>(<span class="keyword">self</span>) bSelf = <span class="keyword">self</span>;</div><div class="line"><span class="comment">//  声明:MMMrcWeak 将bSelf 变成类似 arc下的weak，实现监听，如果当bSelf释放的时候，自动设为nil</span></div><div class="line">MMMrcWeakObserver(bSelf);                                                  </div><div class="line"><span class="comment">//  进行网络请求</span></div><div class="line">[<span class="keyword">self</span> qurey:^&#123;</div><div class="line">    <span class="keyword">if</span> (bSelf) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"bSelf = %@ 这个指针还存在（没有被置为nil，可能是野指针）"</span>, bSelf);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"bSelf 不存在"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>到这里，自动置 nil 的功能已经达到了，似乎这个东西已经可以拿去用了，但是好像发现少了点什么东西，仔细思考后发现，我们只是对 autoNilHelper 这个对象进行了关联 retain，但是并没有在不用的时候解除关联，这样就造成如果 self 不死，可能会关联 N 个 autoNilHelper，这肯定是我们不希望发生的。</p>
<p>那么我们继续加入解除关联的代码，宏大致如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define MMMrcWeakObserverCancel(x)                                                  \</span></div><div class="line"><span class="comment">//	这里就利用了 ptr</span></div><div class="line">objc_setAssociatedObject(x, ptr, <span class="literal">nil</span>, OBJC_ASSOCIATION_RETAIN);                     \</div></pre></td></tr></table></figure>
<p>现在还有一个问题，我们要在下面这段代码中哪里去插入这句代码 <code>MMMrcWeakObserverCancel(bSelf)</code> 呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> qurey:^&#123;</div><div class="line">	<span class="comment">//	在这里？（1）</span></div><div class="line">    <span class="keyword">if</span> (bSelf) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"bSelf = %@ 这个指针还存在（没有被置为nil，可能是野指针）"</span>, bSelf);</div><div class="line">        <span class="comment">// 在这里？（2）</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// 在这里？（3）</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"bSelf 不存在"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 在这里？（4）</span></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这样一看，似乎 （2）和 （4）都需要加入 <code>MMMrcWeakObserverCancel</code>，好像用起来有点蛋疼，于是我将<code>MMMrcWeakObserverCancel</code>的宏改为如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define MMMrcWeakObserverCancel(x)                                                  \</span></div><div class="line">onExit &#123;                                                                            \</div><div class="line">    objc_setAssociatedObject(x, ptr, <span class="literal">nil</span>, OBJC_ASSOCIATION_RETAIN);                 \</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>onExit {...}</code> 这一句的作用是，当跳出当前所在的大括号时，就执行括号中的内容，所以我们就可以理所当然的在一进入 block <code>（1)处</code> 就加入 <code>MMMrcWeakObserverCancel(bSelf)</code> 这句代码，而不必担心关联提早解除。</p>
<p>最终的代码在这里：<br><a href="https://github.com/maquannene/MQAutoNilHelper/tree/master" target="_blank" rel="external"><strong>简单版</strong></a><br><a href="https://github.com/maquannene/MQAutoNilHelper/tree/branch1.1" target="_blank" rel="external"><strong>完整版</strong></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 开发目前已是全民 ARC 的时代，而且苹果的新语言 swift 也只是 ARC的。ARC 环境中，一个 var 声明的是&lt;code&gt;__weak&lt;/code&gt;，那么当这个 var 不再被 &lt;code&gt;__strong&lt;/code&gt; 引用时，这个 &lt;code&gt;__weak&lt;/code&gt; 的 var 就会自动变成 nil，所以大多数情况下不必担心因为没有置 nil 而导致的野指针崩溃。&lt;/p&gt;
&lt;p&gt;但是，如果仍旧使用的是MRC，那么就不得不面对这个问题：&lt;br&gt;网络请求中，大量使用到 block，如果当 block 中引用到了一个被 &lt;code&gt;__block&lt;/code&gt; 关键字声明的变量，并且在这个 block 被回调的时候，这个 var 已经被释放了，那么此时 block 中捕获的这个 var 就成为了一个野指针。Objective-C 中，向一个 nil 的对象发送消息是不会崩溃的，但是对一个野指针发送对象是必然崩溃的。&lt;/p&gt;
&lt;p&gt;那么问题来了，如何在 MRC 下避免这种崩溃的发生。&lt;br&gt;
    
    </summary>
    
      <category term="技术探讨" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E8%AE%A8/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>基于 Octopress 新博客搭建笔记 - Mac 端</title>
    <link href="http://yoursite.com/2015/11/20/2015-11-20-xin-bo-ke-da-jian-bi-ji/"/>
    <id>http://yoursite.com/2015/11/20/2015-11-20-xin-bo-ke-da-jian-bi-ji/</id>
    <published>2015-11-20T09:29:23.000Z</published>
    <updated>2016-01-13T10:02:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实很早就想搭建自己的博客，但是无奈每次想要实施的时候总是被中途的一些东西挫败，其中不乏遇到各种配置环境错误等等，搞得非常烦。上个礼拜终于狠下心研究了一番，搞出了这个还算能看的博客。<br></p>
<p>下面就来记录一下整个博客配置的过程，也许能对你带来一些帮助。<br></p>
<a id="more"></a>
<h4 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h4><p>首先大概讲一下这个博客搭建的流程，博客的搭建其实是利用一个叫做 <code>octopress</code> 的项目，这个项目开源在 GitHub 上，我们将这个项目 clone 到本地，进行一些自定义设定：比如更换主题，更改布局等，当然前提是你需要会写 <code>html</code> <code>css</code> 等；然后再用 <code>markdown</code> 写一些文章， 最后利用这个项目把这些东西生成静态网页，Push 到 GitHub 的 master 上，然后访问响应的域名，就能看到自己的博客了。具体方法会在下面详细讲解。</p>
<h4 id="必备工具："><a href="#必备工具：" class="headerlink" title="必备工具："></a>必备工具：</h4><p><code>Git</code> <code>Ruby</code> 如果你还没有安装这两个东西，请提前安装好。Mac 是自带 Git 的，所以只需要安装 Ruby。 这两个的安装教程不在本篇的范围内，请自己 Google 。<br>申请一个 GitHub 账号，因为我们博客项目最终要托管到 Github 上。<br></p>
<h4 id="第一部分：博客的配置部署"><a href="#第一部分：博客的配置部署" class="headerlink" title="第一部分：博客的配置部署"></a>第一部分：博客的配置部署</h4><h5 id="Clone-和-Install-octopress-项目"><a href="#Clone-和-Install-octopress-项目" class="headerlink" title="Clone 和 Install octopress 项目"></a>Clone 和 Install <code>octopress</code> 项目</h5><p>打开 <code>Terminal</code> ，进到桌面目录，然后输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git://github.com/imathis/octopress.git blog</div></pre></td></tr></table></figure>
<p>从 github 的服务器拉取 <code>octopress</code> 这个项目保存到桌面 <code>blog</code> 文件夹内。</p>
<p>打开 <code>cd blog</code> 进入 <code>blog</code> 文件夹，安装 <code>bundle</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo gem install bundler</div><div class="line">sudo bundle install</div></pre></td></tr></table></figure>
<p><strong>注意：</strong><br><br>1.这里用加 sudo 的原因是因为有些文件可能存在没有写权限的问题，需要通过 <code>chomd</code> 更改权限，如果后续出现权限问题，建议加 <code>sudo</code>。<br><br>2.如果 <code>gem</code> 安装出现了如下错误，请将 Ruby 的源更换为淘宝镜像，具体请怼：<a href="https://ruby.taobao.org" target="_blank" rel="external"><strong>这里</strong></a><br><br><img src="http://ww2.sinaimg.cn/large/65312d9agw1ezoh8xa4k9j20oh00uaab.jpg" alt="here"></p>
<p>安装 <code>octooress</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rake install</div></pre></td></tr></table></figure>
<p>这一步会安装包括博客主题等一些东西，如果不想用默认的主题可以下载别的主题进行更换。<br></p>
<p>完成了上面的四步，博客就算安装完成了，此时就可以小小的预览一下生成的博客了，方法如下：</p>
<p>生成网页的静态页面，并且开启预览端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rake generate</div><div class="line">rake preview</div></pre></td></tr></table></figure>
<p>此时用浏览器打开4000端口就能本地预览了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:4000</div></pre></td></tr></table></figure></p>
<p><strong>Tips:更换主题</strong><br><code>rake install</code> 之后，就已经安装了默认的主题，样式就是<a href="http://blog.devtang.com" target="_blank" rel="external">唐巧的博客</a>的样式<br>当然也可以换成别的样式，比如我用的整个主题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/shashankmehta/greyshade.git .themes/greyshade</div><div class="line">rake install[&apos;greyshade&apos;]</div><div class="line">rake generate</div></pre></td></tr></table></figure>
<p>更多用法可以参考他的 <a href="https://github.com/shashankmehta/greyshade" target="_blank" rel="external"><strong>Github</strong></a></p>
<h5 id="Deploy-Blog-项目到-Github"><a href="#Deploy-Blog-项目到-Github" class="headerlink" title="Deploy Blog 项目到 Github"></a>Deploy Blog 项目到 Github</h5><p>首先我们需要在 Github 新建一个 Repo 用来存放博客的源码和文章，将这个仓库命名必须以以下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;username&gt;.github.com</div></pre></td></tr></table></figure>
<p><strong>注意：</strong><code>username</code> 必须和你 Github 的 <code>登陆账号</code> 一致，否则博客部署到 Github 之后，也不能通过 <code>https://&lt;username&gt;.github.io</code> 来访问。<br>我在这里入过坑，所以在此提醒大家。比如：我 Github 的登陆账号是<code>maquannene</code> ，那么我新建的这个 Repo 仓库的名字就必须是 <code>maquannene.github.com</code>。</p>
<p>接着对本地仓库进行设置，终端输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rake setup_github_pages</div></pre></td></tr></table></figure>
<p>这个指令应该是主要做了这几件事情：<br><br>1.git remote add origin git@github.com:username/username.github.com.git<br><br>增加远程源名为 origin <br><br>2.git branch -m master source <br><br>将本地的分支名字 <code>master</code> 更改为 <code>source</code> <br></p>
<p>此时终端会出现以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Enter the read/write url for your repository:</div></pre></td></tr></table></figure>
<p>意思是需要写入你的仓库 url ，继续输入如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git@github.com:&lt;username&gt;/&lt;username&gt;.github.com.git</div></pre></td></tr></table></figure>
<p>此时需要设置的东西就差不多了，接着就是将工程推到 Github 上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rake generate                             //	生成需要推到 master 的静态网页到_deploy文件夹中</div><div class="line">git add .                                 //	将本地source分支更改的所有文件加入提交目录</div><div class="line">git commit -am &quot;First deploy to github.&quot;  //	提交，并且写入提交日志 &quot;First deploy to github.&quot;</div><div class="line">git push origin source                    //	将add的全部push到远程主机 origin 的 source 分支上</div><div class="line">rake deploy                               //	部署_deploy文件夹里的东西到 origin 的 master 分支</div></pre></td></tr></table></figure>
<p>此时整个博客的就已经部署到 Github 上了，就像 <code>概要</code> 中所说的，博客的静态网页 push 到了 origin 的 master 分支，博客的源码和博文 push 到了 origin 的 source 分支。<br><br>输入<code>git branch</code>显示本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*source</div></pre></td></tr></table></figure>
<p>输入<code>cd _deploy</code> 进入 deploy 文件夹后，输入<code>git branch</code>显示本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*master</div></pre></td></tr></table></figure>
<p>从_deploy中退出来，输入<code>git branch -r</code>就可以看到远程的分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">origin/master</div><div class="line">origin/source</div></pre></td></tr></table></figure>
<p>部署完成完成之后大概等上几分钟就可以通过以下域名访问你的博客了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://&lt;username&gt;.github.io</div></pre></td></tr></table></figure>
<h4 id="第二部分：开始写博客"><a href="#第二部分：开始写博客" class="headerlink" title="第二部分：开始写博客"></a>第二部分：开始写博客</h4><p>部署完成就可以开始写博客了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">rake new_post[&quot;New Post&quot;]             //	新建一个markdown格式的文件，博文就写在这个里面</div><div class="line">rake generate                         //	生成静态网页</div><div class="line">git add .                             //	添加source下的文件，比如刚才添加新的博文文件</div><div class="line">git commit -m &quot;Some comment here.&quot;    //	提交</div><div class="line">git push origin source                //	推到source分支</div><div class="line">rake deploy                           //	自动将静态网页部署到master</div></pre></td></tr></table></figure>
<p>这里你应该发现了，推送博客其实和部署一样，只是更新一下 <code>source</code>分支下的一些博客源文件，然后推到 <code>origin/source</code> 分支，<code>rake generate</code> 生成的静态网页通过 <code>rake deploy</code> 推到 <code>origin/master</code> 分支，就这么简单。</p>
<p>这里说明一下，new_post 新建的 md 文章 和原来的 md 文章全都在 <code>/source/_posts</code> 下，需要更改直接用 md 编辑器编辑即可，编辑器有很多：Mou、MacDown等等…<br></p>
<h4 id="第三部分：换个Mac继续写"><a href="#第三部分：换个Mac继续写" class="headerlink" title="第三部分：换个Mac继续写"></a>第三部分：换个Mac继续写</h4><p>这里主要讲一下，如果换了一个新的环境，怎么 clone 下自己的博客项目，继续写博客：<br></p>
<p>首先将项目的 source 和 master 分支分别从远程 clone 下来 <br><br>命令格式<code>git clone -b &lt;远程分支名称&gt; (仓库url) [本地文件夹名称]</code><br>代码如下:<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone -b source git@github.com:username/username.github.com.git blog</div><div class="line">cd blog</div><div class="line">// 这里注意，master clone 到 _deploy文件夹下面</div><div class="line">git clone -b master git@github.com:username/username.github.com.git _deploy</div></pre></td></tr></table></figure>
<p>然后继续安装bundle:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gem install bundler</div><div class="line">bundle install</div></pre></td></tr></table></figure>
<p>到这里，项目就被 clone 下来并且安装好了，还是同原来一样，博客的源码放在 source 分支，静态网页放在 _deploy 文件夹下的 master 分支，接着就是重复第二部分，可以继续写博客了。<br></p>
<p><strong>Tips：(如果是临时使用的电脑，就可以忽略下面了</strong></p>
<p>如果是自己以后需要长期使用的办公环境，建议生成新的 SSH 并且添加到 GitHub 上，以后提交代码就比较方便了。</p>
<h4 id="第四部分：部署到GitCafe"><a href="#第四部分：部署到GitCafe" class="headerlink" title="第四部分：部署到GitCafe"></a>第四部分：部署到GitCafe</h4><p>国内访问 GitHub 速度目前来说还是不是很理想，所以自然访问我们部署在 GitHub 上的博客速度也不是非常理想，我 ping 了一下，每次访问 GitCafe 的博客时间花费大约在 100ms 左右，而部署在 GitCafe 速度大约 30ms。而且这还是 GitHub 不抽风的状态，有时候如果 github 稍微抽一下疯，那就不知道多久能上去了。所以我在搭建部署在 GitHub 之后又在 GitCafe 部署了一次。<br></p>
<p>部署在 GitCafe 上的过程就比较简单了，大致过程其实和 GitHub 是一样的：<br><br>首先：在注册了 GitHub 的账户之后，建立一个仓库，项目名称必须和你注册的用户名一致，这样 GitCafe 才能将这个项目识别成 Page。</p>
<p>由于我其实只是使用 GitCafe 的 Page，所以不需要将源码托管在这里，当然如果你愿意也可以，我个人只是在这里上传一下静态网页。</p>
<p>在我们执行完 deploy 之后，进到 _deploy 文件夹，然后添加一下 GitCafe 的远程源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add gitcafe git@gitcafe.com:username/username.git &gt;&gt; /dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>接着就能 push 到 GitCafe 上面了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push gitcafe master:gitcafe-pages</div></pre></td></tr></table></figure>
<p>上面的意思是：推送本地分支 <code>master</code> 到 <code>gitcafe</code> 远程源的 <code>gitcafe-pages</code> 分支。<br><br><strong>注意</strong>：个人测试，推送的远程分支必须叫 <code>gitcafe-pages</code>，否则不能显示网页。</p>
<p>接着，输入一下：<code>git branch -r</code><br><br>发现多了一个远程分支：<code>gitcafe/gitcafe-pages</code>，即对应的 GitCafe 远程源的gitcafe-pages分支。</p>
<p>对了，记得也设置一下 GitCafe 上的 SSH，以后提交就比较方便了。</p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>如果有什么问题并且我能帮到你，请点击左边的<code>微博</code>按钮私信我，或者在下面给我留言，工作日我会以非常快的速度秒回你。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实很早就想搭建自己的博客，但是无奈每次想要实施的时候总是被中途的一些东西挫败，其中不乏遇到各种配置环境错误等等，搞得非常烦。上个礼拜终于狠下心研究了一番，搞出了这个还算能看的博客。&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;下面就来记录一下整个博客配置的过程，也许能对你带来一些帮助。&lt;/br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="装逼指南" scheme="http://yoursite.com/categories/%E8%A3%85%E9%80%BC%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
